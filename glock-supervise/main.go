package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/gbagnoli/glock"
)

type cHostsFlag struct {
	hosts []string
}

func (f *cHostsFlag) Hosts() []string {
	if len(f.hosts) == 0 {
		return []string{"localhost"}
	}
	return f.hosts
}

func (f *cHostsFlag) String() string {
	return fmt.Sprint(f.hosts)
}

func (f *cHostsFlag) Set(value string) error {
	if len(f.hosts) > 0 {
		return errors.New("cassandra hosts are already set")
	}

	hosts := strings.Split(value, ",")
	for _, elem := range hosts {
		f.hosts = append(f.hosts, elem)
	}
	return nil
}

var driver = flag.String("driver", "cassandra", "driver to use")
var name = flag.String("lock", "", "lock name. Required")
var id = flag.String("client-id", "", "if unset, it will be autogenerated")
var ttl = flag.Duration("lock-ttl", time.Duration(30)*time.Second, "TTL for the lock")
var wait = flag.Duration("max-wait", time.Duration(-1), "How long to wait for the lock to be acquired. If <= 0, no wait at all")
var quiet = flag.Bool("quiet", false, "Disable logging in glock")

var redisAddress = flag.String("redis-server", "localhost:6379", "redis server address (with port)")
var redisNS = flag.String("redis-namspace", "glock", "namespace for keys in redis. Default is used even if set to be empty on commandline")

var cHosts cHostsFlag
var cassandraKS = flag.String("cassandra-ks", "glock", "cassandra keyspace")
var cassandraTable = flag.String("cassandra-table", "glock", "cassandra table")
var cassandraUsername = flag.String("cassandra-username", "", "cassandra username")
var cassandraPassword = flag.String("cassandra-password", "", "cassandra password")
var cassandraReplFactor = flag.Int("cassandra-replication-factor", 1, "Cassandra replication factor (only used if ks needs to be created")

func main() {
	flag.Var(&cHosts, "cassandra-hosts", "Comma separated list of cassandra hosts")
	flag.Parse()

	var client glock.Client
	var err error

	switch *driver {
	case "cassandra":
		opts := glock.CassandraOptions{
			Hosts:             cHosts.Hosts(),
			KeySpace:          *cassandraKS,
			TableName:         *cassandraTable,
			Username:          *cassandraUsername,
			Password:          *cassandraPassword,
			ReplicationFactor: *cassandraReplFactor,
		}
		client, err = glock.NewCassandraLockClient(opts)

	case "redis":
		opts := glock.RedisOptions{
			Network:   "tcp",
			Address:   *redisAddress,
			Namespace: *redisNS,
		}
		client, err = glock.NewRedisClient(opts)

	default:
		log.Fatalf("Invalid value for --driver '%s'", *driver)
	}

	if err != nil {
		log.Fatalf("Cannot create lock client: %s", err.Error())
	}

	if *name == "" {
		log.Print("Missing lock name (required)")
		flag.Usage()
		os.Exit(1)
	}

	if *id != "" {
		client.SetID(*id)
	}

	args := flag.Args()
	commandStr := strings.Join(args, " ")

	options := glock.AcquireOptions{
		TTL:     *ttl,
		MaxWait: *wait,
		Data:    commandStr,
	}
	execOpts := glock.ExecOptions{Options: options}
	manager := glock.NewLockManager(client, options)

	if !*quiet {
		manager.Logger.SetOutput(os.Stderr)
	}

	manager.Logger.Printf("Using driver: %s", *driver)
	manager.Logger.Printf("Running: %s", commandStr)
	command := exec.Command(args[0], args[1:]...)
	command.Stdin = os.Stdin
	command.Stdout = os.Stdout
	command.Stderr = os.Stderr

	res, err := manager.Exec(*name, command, execOpts)
	if err != nil {
		log.Fatal(err)
	}
	os.Exit(res)
}
